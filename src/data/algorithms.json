[
  {
    "id": 1,
    "title": "The Potential Method",
    "description": "The potential method is an analytical tool used to reason about the number of steps needed to run and complete a complex algorithm. For example, suppose we have a game using an 11 x 11 board of 'O' and 'M' tiles. The game's premise is that one player can flip a row of tiles, and the other player can flip a column. However, only columns or rows can be flipped when there are more O's than M's in said column or row. Using the potential method, we can determine whether there is a finite bound on the number of turns required for a game of arbitrary size to end.",
    "componentID": "PotentialMethod",
    "status": "live",
    "noteLink": "https://eecs376.github.io/notes/algorithms.html#the-potential-method",
    "wikiLink": "https://en.wikipedia.org/wiki/Potential_method"
  },
  {
    "id": 2,
    "title": "Closest Pair Problem",
    "description": "In the closest pair problem, we are provided n points in d-dimensional space, and the goal is to find the closest pair of points. Often encountered in the field of computational geometry, this problem was one of the first geometric problems whose computational complexity was systematically studied. A naive solution to this problem would attempt to evaluate every pair of points, which has a O(n^2) complexity. However, a more efficient divide and conquer algorithm can be utilized, and as the animation demonstrates, clever algorithmic strategies can bring the complexity down to O(n log n).",
    "componentID": "ClosestPair",
    "status": "live",
    "noteLink": "https://eecs376.github.io/notes/algorithms.html#the-closest-pair-problem",
    "wikiLink": "https://en.wikipedia.org/wiki/Closest_pair_of_points_problem"
  },
  {
    "id": 3,
    "title": "Merge Sort",
    "description": "The divide-and-conquer algorithmic pattern involves subdividing a large, complex problem instance into smaller versions of the same problem. The subproblems are solved recursively, and their solutions ... divide and conquer is a recursive paradigm, the main tool for analyzing divide-and-conquer algorithms is induction. When it comes to complexity analysis, such algorithms generally give rise to recurrence relations expressing the time or space complexity. While these relations can be solved inductively, we usually rely on other tools to do so. We will see one such tool in the form of the master theorem.",
    "componentID": "MergeSort",
    "status": "hidden",
    "noteLink": "https://eecs376.github.io/notes/algorithms.html#divide-and-conquer",
    "wikiLink": "https://en.wikipedia.org/wiki/Merge_sort"
  },
  {
    "id": 4,
    "title": "Euclid's Algorithm",
    "description": "EUCLID had a sick alg, brah! Look at it goooo brah! versions of the same problem. The subproblems are solved recursively, and their solutions ... divide and conquer is a recursive paradigm, the main tool for analyzing divide-and-conquer algorithms is induction. When it comes to complexity analysis, such algorithms generally give rise to recurrence relations expressing the time or space complexity. While these relations can be solved inductively, we usually rely on other tools to do so. We will see one such tool in the form of the master theorem.",
    "componentID": "Euclid",
    "status": "hidden",
    "noteLink": "https://eecs376.github.io/notes/algorithms.html#divide-and-conquer",
    "wikiLink": "https://en.wikipedia.org/wiki/Merge_sort"
  }
]
